

```{ojs}
//| echo: false
viewof vennDiagramWithLegend = html`
    <div style="display: flex; justify-content: space-between;align-items: center;">
        ${draw_venn()}
        ${drawLegend()}
    </div>`
```

```{ojs}
//| echo: false
N_ALL = N_A + N_B - nAAndB + nNotOrAB;
mutable nAAndB = 2;

viewof interactiveA = html`nA:<br/>${numberOfA} ${sliderA}`;
viewof interactiveB = html`nB:<br/>${numberOfB} ${sliderB}`;
viewof interactiveNotOrAB = html`nNotOr(AB): <br/>${numberOfNotOrAB} ${sliderC}`
```

```{ojs}
//| echo: false
{
  viewof vennDiagramWithLegend.addEventListener("update", listener);
  invalidation.then(() => viewof vennDiagramWithLegend.removeEventListener("update", listener));
  viewof vennDiagramWithLegend.dispatchEvent(new CustomEvent("update"));
}
```

```{ojs}
//| echo: false
function drawLegend(){
  var legend = html`
<div id="legend">
  <div id="box" style="display:flex; flex-direction: column;">
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px; background-color: rgba(218, 218, 217, 0.57); cursor:pointer;border:3px solid transparent;" id="div-omega"></div>
      <p style="padding: 0px 7px;">Ω</p>
    </div>
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px;background-color: rgba(31, 119, 180, 0.3); cursor:pointer;border:3px solid transparent;" id="div-A"></div>
      <p style="padding: 0px 7px;">A</p>
    </div>
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px;background-color: rgba(255, 127, 14, 0.3); cursor:pointer;border:3px solid transparent;" id="div-B"></div>
      <p style="padding: 0px 7px;">B</p>
    </div>
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px;background-color: rgba(143, 123, 97, 0.3); cursor:pointer;border:3px solid transparent;" id="div-A-intersect-B"></div>
      <p style="padding: 0px 7px;">A ∩ B</p>
    </div>
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px;
background: linear-gradient(90deg, rgba(31,119,180,0.3) 0%, rgba(255,127,14,0.3) 100%); cursor:pointer;border:3px solid transparent;" id="div-A-union-B"></div>
      <p style="padding: 0px 7px;">A ∪ B</p>
    </div>
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px;background-color: rgba(31, 119, 180, 0.3); cursor:pointer;border:3px solid transparent;" id="div-A-and-not-B"></div>
      <p style="padding: 0px 7px;">A ∩ B'</p>
    </div>
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px;background-color: rgba(255, 127, 14, 0.3); cursor:pointer;border:3px solid transparent;" id="div-not-A-and-B"></div>
      <p style="padding: 0px 7px;">B ∩ A'</p>
    </div>
    <div style="display:flex;align-items: center" >
      <div style="width:30px;height:30px;border-radius:3px; background-color: rgba(218, 218, 217, 0.57); cursor:pointer;border:3px solid transparent;" id="div-not-A-intersect-not-B"></div>
      <p style="padding: 0px 7px;">A' ∩ B'</p>
    </div>
  </div>
</div>
`
    return legend;
}
```


```{ojs}
//| echo: false
function listener() {
  var unionTemp = document.getElementById('union-temp');
  var legendA = document.getElementById('div-A');
  var circleA = document.getElementById('circle-A');
  var legendB = document.getElementById('div-B');
  var circleB = document.getElementById('circle-B');
  var legendAAndB = document.getElementById("div-A-intersect-B");
  var pathAAndB = document.getElementById("intersection-A-B");
  var legendNotAIntersectNotB = document.getElementById("div-not-A-intersect-not-B");
  var legendOmega = document.getElementById("div-omega");
  var legendAIntersectNotB = document.getElementById("div-A-and-not-B");
  var legendNotAIntersectB = document.getElementById("div-not-A-and-B");
  var venn = document.getElementById("venn-id");
  var legendAUnionB = document.getElementById("div-A-union-B");
  var pathAUnionB = document.getElementById("union-all");
  
  var rightPathAAndB = document.getElementById("intersection-right-A-B");
  var leftPathAAndB = document.getElementById("intersection-left-A-B");
  var circleBColor = 'rgb(255, 127, 14)';
  var pathAAndBColor = '#8f7b614d';
  var legendDataInJson = {
    'A': 'A',
    'B': 'B',
    'A_AND_B': 'A_AND_B',
    'A_UNION_B': 'A_UNION_B',
    'NOT_A_AND_NOT_B': 'NOT_A_AND_NOT_B',
    'A_AND_NOT_B': 'A_AND_NOT_B',
    'NOT_A_AND_B': 'NOT_A_AND_B',
    'OMEGA': 'OMEGA',
    'NONE': ''
  }
  
  var selectedLegend = ''
  
  moveToFront(pathAAndB);
  
  selectAEventListener();
  selectBEventListener();
  selectOmegaEventListener();
  selectNotAAndNotBEventListener();
  selectAAndNotBEventListener();
  selectNotAAndBEventListener();
  selectAAndBEventListener();
  selectAUnionBEventListener();
  
  function isInsideBigCircle(currentCircle){
    if(N_A == nAAndB && currentCircle == 'A') return true;
    if(N_B == nAAndB && currentCircle == 'B') return true;
  }
  
  function selectAEventListener(){
    legendA.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectA();
        updateLegend(legendA, 'rgba(31, 119, 180, 1)', true)
      }
    })
  
    legendA.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectA();
        updateLegend(legendA, 'rgba(31, 119, 180, 0.3)', false)
      }
    })
    
    legendA.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['A']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectA();
        updateLegend(legendA, 'rgba(31, 119, 180, 0.3)', false)
      }else if(isNotClickedLegend()){
          handleSelectA();
          updateLegend(legendA, 'rgba(31, 119, 180, 1)', true)
          selectedLegend = legendDataInJson['A'];
      }
    })
   }
  
   function selectBEventListener(){
    legendB.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectB();
        updateLegend(legendB, 'rgba(255, 127, 14, 1)', true)
      }
    })
  
    legendB.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectB();
        updateLegend(legendB, 'rgba(255, 127, 14, 0.3)', false)
      }
    })
     
     legendB.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['B']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectB();
        updateLegend(legendB, 'rgba(255, 127, 14, 0.3)', false)
      }else if(isNotClickedLegend()){
        selectedLegend = legendDataInJson['B'];
        handleSelectB();
        updateLegend(legendB, 'rgba(255, 127, 14, 1)', true)
      }
    })
  }
  
  function isNotClickedLegend(){
    return selectedLegend === ''
  }
  
  function handleSelectA(){
      moveToFront(circleA)
      showCircle(circleA)
      hidePathAndLabel(circleB);
      hidePathAndLabel(pathAAndB);
  }
  
  function handleDeselectA(){
      showPathAndLabel(circleB);
      showPathAndLabel(pathAAndB);
      resetCircle(circleA);
  }
  
  function handleSelectB(){
      moveToFront(circleB)
      showCircle(circleB);
      hidePathAndLabel(circleA);
      hidePathAndLabel(pathAAndB);
  }
  
  function handleDeselectB(){
      showPathAndLabel(circleA);
      showPathAndLabel(pathAAndB);
      resetCircle(circleB);
  }
  
  function selectAAndBEventListener(){
    legendAAndB.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectAAndB();
      }
    })
  
    legendAAndB.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectAAndB();
      }
    })
    
    legendAAndB.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['A_AND_B']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectAAndB();
      }else if(isNotClickedLegend()){
        selectedLegend = legendDataInJson['A_AND_B'];
        handleSelectAAndB();
      }
    })
  }
  
  function handleSelectAAndB(){
      if(isInsideBigCircle('A')){
        handleSelectA()
      }
      else if(isInsideBigCircle('B')){
        handleSelectB()
      }
      else {
      moveToFront(pathAAndB)
      hidePathAndLabel(circleA);
      hidePathAndLabel(circleB);
      pathAAndB.style.setProperty("fill-opacity", .8);
      pathAAndB.style.setProperty("fill", pathAAndBColor);
      updateStroke(pathAAndB, "white", 1);
      
     }
      updateLegend(legendAAndB, 'rgba(143, 123, 97, 1)', true)
      
  }
  
  function handleDeselectAAndB(){
      if(isInsideBigCircle('A')){
        handleDeselectA()
      }
      else if(isInsideBigCircle('B')){
        handleDeselectB()
      }
      else {
        showPathAndLabel(circleA);
        showPathAndLabel(circleB);
        resetIntersection(pathAAndB);
      }
      updateLegend(legendAAndB, 'rgba(143, 123, 97, 0.3)', false);
  }
  
  function selectAUnionBEventListener(){
    legendAUnionB.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectAUnionB();
      }
    })
  
    legendAUnionB.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectAUnionB();
      }
    })
    
    legendAUnionB.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['A_UNION_B']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectAUnionB();
      }else if(isNotClickedLegend()){
        selectedLegend = legendDataInJson['A_UNION_B'];
        handleSelectAUnionB();
      }
    })
  }
  
  function handleSelectAUnionB(){
      if(isInsideBigCircle('A')){
        handleSelectB();
      }
      else if(isInsideBigCircle('B')){
        handleSelectA();
      }
      else {
      showCircle(circleA);
      showCircle(circleB);
      moveToFront(circleB);
      moveToFront(pathAAndB);
      updateColor(pathAAndB, circleBColor, 1);
      updateStroke(pathAAndB, circleBColor, 1);
      }
    legendAUnionB.style.setProperty("background", 'linear-gradient(90deg, rgba(31,119,180,1) 0%, rgba(255,127,14,1) 100%)');
  }
  
  function handleDeselectAUnionB(){
      if(isInsideBigCircle('A')){
        handleDeselectB();
      }
      else if(isInsideBigCircle('B')){
        handleDeselectA();
      }
      else {
        resetCircle(circleB);
        resetCircle(circleA);
        resetIntersection(pathAAndB);
      }
    legendAUnionB.style.setProperty("background", 'linear-gradient(90deg, rgba(31,119,180,0.3) 0%, rgba(255,127,14,0.3) 100%)');
  }
  
  function selectNotAAndNotBEventListener(){
    legendNotAIntersectNotB.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectNotAIntersectNotB();
      }
    })
  
    legendNotAIntersectNotB.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectNotAIntersectNotB();
      }
    })
    
    legendNotAIntersectNotB.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['NOT_A_AND_NOT_B']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectNotAIntersectNotB();
      }else if(isNotClickedLegend()){
        selectedLegend = legendDataInJson['NOT_A_AND_NOT_B'];
        handleSelectNotAIntersectNotB();
      }
    })
  
  }
  
  function handleSelectNotAIntersectNotB(){
    if(isInsideBigCircle('A')){
        hidePathAndLabel(circleA);
        moveToFront(circleB);
        updateStroke(circleB, "white", 1);
      }
      else if(isInsideBigCircle('B')){
        hidePathAndLabel(circleB);
        moveToFront(circleA);
        updateStroke(circleA, "white", 1);
      }
      else {
      updateStroke(circleA, "white", 1);
      updateStroke(circleB, "white", 1);
      updateStroke(pathAAndB, "#8f7b61", 1);
      moveToFront(pathAAndB);
      }
      pathAAndB.style.setProperty("fill-opacity", 0);
      venn.style.setProperty("border", '1px ridge white');
      venn.style.setProperty("background-color", '#9a9a9aba');
      updateLegend(legendNotAIntersectNotB, 'rgba(80, 80, 80, 1)', true);
  }
  
  function handleDeselectNotAIntersectNotB(){
    if(isInsideBigCircle('A')){
        showPathAndLabel(circleA);
        resetCircle(circleB)
      }
      else if(isInsideBigCircle('B')){
        showPathAndLabel(circleB);
        resetCircle(circleA)
      }
      else {
      resetCircle(circleA)
      resetCircle(circleB)
     }
      venn.style.setProperty("border", '1px solid salmon');
      venn.style.setProperty("background-color", '#dadad991');
      pathAAndB.style.setProperty("stroke", "transparent");
      updateLegend(legendNotAIntersectNotB, 'rgba(218, 218, 217, 0.57)', false)
  }
  
  function selectAAndNotBEventListener(){
    legendAIntersectNotB.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectAIntersectNotB();
      }
    })
  
    legendAIntersectNotB.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectAIntersectNotB();
      }  
    });
    
    legendAIntersectNotB.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['A_AND_NOT_B']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectAIntersectNotB();
      }else if(isNotClickedLegend()){
        selectedLegend = legendDataInJson['A_AND_NOT_B'];
        handleSelectAIntersectNotB();
      }
    })
   }
  
  function handleSelectAIntersectNotB(){
    if(isInsideBigCircle('A')){
        hidePathAndLabel(circleA);
        hidePathAndLabel(circleB);
        hidePathAndLabel(pathAAndB);
      }
      else if(isInsideBigCircle('B')){
        showCircle(circleA);
        moveToFront(circleB)
        showCircle(circleB);
      }
      else {
      showCircle(circleA);
      moveToFront(pathAAndB);
      moveToFront(rightPathAAndB);
      hidePathAndLabel(circleB);
      updateColor(pathAAndB, "#dadadc", 1);
      updateStroke(pathAAndB, "white", 1);
      updateStroke(rightPathAAndB, "#dadadc", 1);
      updateColor(rightPathAAndB, "#dadadc", 1);
      }
      updateLegend(legendAIntersectNotB, 'rgba(31, 119, 180, 1)', true);
  }
  
  function handleDeselectAIntersectNotB(){
    if(isInsideBigCircle('A')){
        showPathAndLabel(circleA);
        showPathAndLabel(circleB);
        showPathAndLabel(pathAAndB);
      }
      else if(isInsideBigCircle('B')){
        resetCircle(circleB);
        resetCircle(circleA);
      }
      else {
        resetCircle(circleA)
        showPathAndLabel(circleB);
        resetIntersection(rightPathAAndB);
        resetIntersection(pathAAndB);
      }
      updateLegend(legendAIntersectNotB, 'rgba(31, 119, 180, 0.3)', false)
  }
  
  function selectNotAAndBEventListener(){
    legendNotAIntersectB.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectNotAIntersectB();
      }
    })
  
    legendNotAIntersectB.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectNotAIntersectB();
      }  
    });
    
    legendNotAIntersectB.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['NOT_A_AND_B']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectNotAIntersectB();
      }else if(isNotClickedLegend()){
        selectedLegend = legendDataInJson['NOT_A_AND_B'];
        handleSelectNotAIntersectB();
      }
    })
   }
  
  function handleSelectNotAIntersectB(){
      if(isInsideBigCircle('B')){
        hidePathAndLabel(circleA);
        hidePathAndLabel(circleB);
        hidePathAndLabel(pathAAndB);
      }
      else if(isInsideBigCircle('A')){
        showCircle(circleB);
        moveToFront(circleA)
        showCircle(circleA);
      }
      else {
      showCircle(circleB);
      moveToFront(pathAAndB);
      moveToFront(leftPathAAndB);
      hidePathAndLabel(circleA);
      updateColor(pathAAndB, "#dadadc", 1);
      updateColor(leftPathAAndB, "#dadadc", 1);
      updateStroke(pathAAndB, "white", 1);
      updateStroke(leftPathAAndB, "#dadadc", 1);
      }
      updateLegend(legendNotAIntersectB, 'rgba(255, 127, 14, 1)', true)
   }
  
  function handleDeselectNotAIntersectB(){
    if(isInsideBigCircle('B')){
        showPathAndLabel(circleA);
        showPathAndLabel(circleB);
        showPathAndLabel(pathAAndB);
      }
      else if(isInsideBigCircle('A')){
        resetCircle(circleB);
        resetCircle(circleA);
      }
      else {
      resetCircle(circleB);
      showPathAndLabel(circleA);
      resetIntersection(leftPathAAndB);
      resetIntersection(pathAAndB);
      }
      updateLegend(legendNotAIntersectB, 'rgba(255, 127, 14, 0.3)', false)
  }
  
  function selectOmegaEventListener(){
    legendOmega.addEventListener("mouseover", function() {
      if(isNotClickedLegend()){
        handleSelectOmega();
      }
    })
  
    legendOmega.addEventListener("mouseout", function() {
      if(isNotClickedLegend()){
        handleDeselectOmega();
      }  
    });
    
    legendOmega.addEventListener("click", function() {
      if(selectedLegend == legendDataInJson['OMEGA']){
        selectedLegend = legendDataInJson['NONE'];
        handleDeselectOmega();
      }else if(isNotClickedLegend()){
        selectedLegend = legendDataInJson['OMEGA'];
        handleSelectOmega();
      }
    })
   }
  
  function handleSelectOmega(){
      changeParentNodeOpacity(circleA.parentNode.parentNode, 0);
      venn.style.setProperty("border", '1px ridge white');
      venn.style.setProperty("background-color", '#dcdcdc');
      updateLegend(legendOmega, 'rgba(80, 80, 80, 1)', true)
  }
  
  function handleDeselectOmega(){
      showPathAndLabel(circleA.parentNode.parentNode);
      venn.style.setProperty("border", '1px solid salmon');
      venn.style.setProperty("background-color", '#dadad991');
      updateLegend(legendOmega, 'rgba(218, 218, 217, 0.57)', false)
  }
  
  function updateLegend(selectedNode, color, isSelect){
    selectedNode.style.setProperty("background-color", color);
    if(isSelect){
      selectedNode.style.setProperty("border", '3px outset white');
    }else{
      selectedNode.style.setProperty("border", '3px solid transparent');
    }
  }
  
  function updateColor(selectedNote, color, opacity){
      selectedNote.style.setProperty("fill", color);
      selectedNote.style.setProperty("fill-opacity", opacity);
  }
  
  
  function updateStroke(selectedNote, color, opacity){
      selectedNote.style.setProperty("stroke", color);
      selectedNote.style.setProperty("stroke-opacity", opacity);
  }
  
  function showCircle(selectedNode){
      selectedNode.style.setProperty("fill-opacity", 0.8);
      selectedNode.style.setProperty("stroke", "white");
      selectedNode.style.setProperty("stroke-opacity", 1);
  }
  
  function resetCircle(selectedNode){
      selectedNode.style.setProperty("fill-opacity", .3);
      selectedNode.style.setProperty("stroke-opacity", 0);
  }
  
  function resetIntersection(selectedNode){
    selectedNode.style.setProperty("fill-opacity", 0);
      selectedNode.style.setProperty("fill", "white");
      selectedNode.style.setProperty("stroke", "white");
      selectedNode.style.setProperty("stroke-opacity", 0);
    moveToFront(circleB);
    moveToFront(circleA);
  }
  
  function showPathAndLabel(selectedNote) {
     changeParentNodeOpacity(selectedNote, 1)
  };
  
  function hidePathAndLabel(selectedNote) {
     changeParentNodeOpacity(selectedNote, 0.2)
  };
  
  function changeParentNodeOpacity(selectedNote, opacity) {
     selectedNote.parentNode.style.setProperty("opacity", opacity);
  };
  
  function moveToFront(selectedNote) {
     selectedNote.parentNode.parentNode.appendChild(selectedNote.parentNode);
  };
  
}
```



```{ojs}
//| echo: false
S_MAX = 500 * 500
sA = N_A / N_ALL * S_MAX
```


```{ojs}
//| echo: false
function draw_venn() {
  const node = DOM.svg(hRect, wRect);
  var isMoveInChildElement = false;
  var diagram,
      init = true,
      elem = d3.select(node).attr('style', 'border: 1px solid salmon; background-color: #dadad991').attr("id", "venn-id"),
      tooltip = d3.select(node).append("div").attr("class", "venntooltip").attr('style', 'z-index: 100');
  
  elem.on("mousemove", function() {
        if(!isMoveInChildElement){
          d3.select(this)
            .style("border", '1px solid white')
            .style("background-color", '#dcdcdc');
        }
        
      })
      .on("mouseleave", function(d, i) {
        var selection = d3.select(this)
        .attr('style', 'border: 1px solid salmon; background-color: #dadad991')
   })
    
  d3.select(node).append("text").attr("x", hRect - 50 - fontSize )
               .attr("y", wRect - 20 - fontSize )
                .style("fill", "#003263")
                .style("stroke", "#003263")
               .attr("font-size", fontSize)
                .attr("text-anchor", "middle")
               .text(function() { return data.sets.reduce((a , b)=> {
                  const newCharacter = a ==='Not ' ?  'Not ' : a + "⋃"
                  return newCharacter + b.label
                }, 'Not ')});
  
  load()
  function load() {
    var vennObj, sets, overlaps;
      sets = data.sets;
      overlaps = data.overlaps

    // get positions for each set
    vennObj = venn.venn(sets, overlaps);
  
    if (init) {
      // draw the diagram in the 'venn' div
      diagram = venn.drawD3Diagram(elem, vennObj,wRect, hRect);
      init = false;
    }
    else {
      venn.updateD3Diagram(elem, vennObj);
    }

    // hover on all the circles
    diagram.circles
      .style("stroke-opacity", 0)
      .style("stroke", "white")
      .style("stroke-width", "2")
      .on("mousemove", function() {
        var x = d3.event.pageX;
        var y = d3.event.pageY;
        tooltip.style("left", (x) + "px")
        .style("top", (y) + "px");
      })
      .on("mouseover", function(d, i) {
        var selection = d3.select(this);
        d3.select(this).moveParentToFront()
        .transition()
        .style("fill-opacity", .5)
        .style("stroke-opacity", 1);

        tooltip.transition().style("opacity", .9);
        tooltip.text(d.number);
        isMoveInChildElement = true;
        d3.select(node).attr('style', 'border: 1px solid salmon; background-color: #dadad991')
      })
      .on("mouseout", function(d, i) {
        d3.select(this).transition()
        .style("fill-opacity", .3)
        .style("stroke-opacity", 0);
        tooltip.transition().style("opacity", 0);
      isMoveInChildElement = false;
      });

    overlaps = overlaps.map(value => {
      const dxO1O2 = Math.abs(data.sets[value.sets[0]].x-data.sets[value.sets[1]].x)
      let deltaX = Math.abs(data.sets[value.sets[0]].radius + data.sets[value.sets[1]].radius - dxO1O2) / 2
      return {
        ...value,
        x: data.sets[value.sets[0]].x + data.sets[value.sets[0]].radius - deltaX ,
        y: value.sets.reduce((a, b) => {
          return a + data.sets[b].y
        }, 0) / 2,
      }
    })
    
    // draw a path around each intersection area, add hover there as well
    var intersections = diagram.svg.select("g").append("g").selectAll("path")
      .data(overlaps)
    var intersects = intersections
      .enter();
    
    intersects.append("text")
      .attr("id", function(d) { return `intersection-text-${data.sets[d.sets[0]].label}-${data.sets[d.sets[1]].label}` })
      .attr("x", function(d, i) { return d.x })
      .attr("y", function(d, i) { return d.y })
      .style("fill", "#9D4057")
      .style("stroke", "#9D4057")
      .attr("font-size", fontSize)
      .attr("text-anchor", "middle")
      .text(function(d) { 
        if (d.size > 0) return `${data.sets[d.sets[0]].label} ∩ ${data.sets[d.sets[1]].label}`
        return ''
      });
    
      intersects.append("path")
      .attr("id", function(d) { return `intersection-${data.sets[d.sets[0]].label}-${data.sets[d.sets[1]].label}` })
      .style("fill-opacity","0")
      .style("fill", "black")
      .style("stroke-opacity", 0)
      .style("stroke", "white")
      .style("stroke-width", "2")
    
    intersections
      .attr("d", function(d) { 
        return venn.intersectionAreaSplitPath(d.sets.map(function(j) { return vennObj[j]; }), true, true); 
      })
      .on("mouseover", function(d, i) {
        d3.select(this).moveParentToFront()
        d3.select(this).transition()
        .style("fill-opacity", .1)
        .style("stroke-opacity", 1);
        tooltip.transition().style("opacity", 1);
        tooltip.text(d.number);
        isMoveInChildElement = true;
      })
      .on("mouseout", function(d, i) {
        d3.select(this).moveParentToFront();
        d3.select(this).transition()
        .style("fill-opacity", 0)
        .style("stroke-opacity", 0);
        tooltip.transition().style("opacity", 1);
        isMoveInChildElement = false;
        d3.select(node).attr('style', 'border: 1px solid salmon; background-color: #dadad991')
      })
      .on("mousemove", function() {
        tooltip.style("left", (d3.event.pageX) + "px")
        .style("top", (d3.event.pageY - 28) + "px");
      });
    
    //
    var rightIntersections = diagram.svg.select("g").append("g").selectAll("path")
      .data(overlaps)
    var rightIntersects = rightIntersections
      .enter();
    
    rightIntersects.append("path")
      .attr("id", function(d) { return `intersection-right-${data.sets[d.sets[0]].label}-${data.sets[d.sets[1]].label}` })
      .style("fill-opacity","0")
      .style("fill", "black")
      .style("stroke-opacity", 0)
      .style("stroke", "white")
      .style("stroke-width", "2")

    rightIntersections
      .attr("d", function(d) { 
        return venn.intersectionAreaSplitPath(d.sets.map(function(j) { return vennObj[j]; }), true, false); 
      })
    
    //
    var leftIntersections = diagram.svg.select("g").append("g").selectAll("path")
      .data(overlaps)
    var leftIntersects = leftIntersections
      .enter();
    
    leftIntersects.append("path")
      .attr("id", function(d) { return `intersection-left-${data.sets[d.sets[0]].label}-${data.sets[d.sets[1]].label}` })
      .style("fill-opacity","0")
      .style("fill", "black")
      .style("stroke-opacity", 0)
      .style("stroke", "white")
      .style("stroke-width", "2")

    leftIntersections
      .attr("d", function(d) { 
        return venn.intersectionAreaSplitPath(d.sets.map(function(j) { return vennObj[j]; }), false, true); 
      })
    
    intersections.exit().remove();
  }  
  

  d3.selection.prototype.moveParentToFront = function() {
    return this.each(function(){
      this.parentNode.parentNode.appendChild(this.parentNode);
    });
  };
  
  return elem.node()
}
```


```{ojs}
//| echo: false
rA = Math.sqrt(sA / Math.PI)
sB = N_B / N_ALL * S_MAX
rB = Math.sqrt(sB / Math.PI)
sBoth = nAAndB / N_ALL * S_MAX
delta = (rA + rB) / 10
hRect = 800//( rA + rB ) * 2 + 2 * delta
wRect = 400//2 * d3.max([rA, rB]) + 2 * delta
fontSize = hRect / 30
mutable N_A = 10

numberOfA = {
  const input = html`<input type="number" max=100 style="width:50px;height:20px" />`
  input.onchange = () => {
      mutable N_A = input.valueAsNumber;
  }
  return html`${input}`;
}

numberOfB = {
  const input = html`<input type="number" max=100 style="width:50px;height:20px"/>`
  input.onchange = (event) => {
    mutable N_B = input.valueAsNumber;
  }
  return html`${input}`;
}

numberOfNotOrAB = {
  const input = html`<input type="number" max=100 style="width:50px;height:20px"/>`
  input.onchange = () => {
    mutable nNotOrAB = input.valueAsNumber;
  }
  return html`${input}`;
}

sliderA = {
  const input = html`<input type="range" min="0" max=${N_A} step="1" value=${nAAndB} />`
  input.oninput = () => {
    if(input.valueAsNumber <= maxNAAndB){
      mutable nAAndB = input.valueAsNumber;
    }
    else{
     mutable nAAndB = maxNAAndB;
    }
  };
  return html`0 ${input} nA`;
}
```


```{ojs}
//| echo: false
nAAndNotB = N_A - nAAndB;
mutable N_B = 5
nBAndNotA = N_B - nAAndB
maxNAAndB = Math.min(N_A, N_B)

sliderB = {
  const input = html`<input type="range" min="0" max=${N_B} step="1" value=${nAAndB} />`
  input.oninput = () => {
    if(input.valueAsNumber <= maxNAAndB){
      mutable nAAndB = input.valueAsNumber;
    }
    else{
     mutable nAAndB = maxNAAndB;
    }
  };
  return html`0 ${input} nB`;
}

mutable nNotOrAB =0


sliderC = {
  const input = html`<input type="range" min="0" max=${N_A + N_B + nNotOrAB} step="1" value=${nAAndB} />`
  input.oninput = () => {
    if(input.valueAsNumber <= maxNAAndB){
      mutable nAAndB = input.valueAsNumber;
    }
    else{
     mutable nAAndB = maxNAAndB;
    }
  };
  return html`0 ${input} nA + nB + nNot(AorB)`;
}

data = {
  return{
    "sets": [
      {"label": "A", "size": sA, "number": N_A},
      {"label": "B", "size": sB,"number": N_B},
      // {"label": "C", "size": 40000,"number": N_B},
    ],
    "overlaps": [
      { "sets": [0, 1], "size": sBoth, "number": nAAndB},
      // {"sets": [0, 2], "size": 10000, "number": nAAndB},
      // {"sets": [1, 2], "size": 10000, "number": nAAndB},
    ]
  }
}
```


```{ojs}
//| echo: false
venn = {
 let venn = {};
  /** given a list of set objects, and their corresponding overlaps.
    updates the (x, y, radius) attribute on each set such that their positions
    roughly correspond to the desired overlaps */
    venn.venn = function(sets, overlaps, parameters) {
        parameters = parameters || {};
        parameters.maxIterations = parameters.maxIterations || 500;
        var lossFunction = parameters.lossFunction || venn.lossFunction;
        var initialLayout = parameters.layoutFunction || venn.greedyLayout;

        // initial layout is done greedily
        sets = initialLayout(sets, overlaps);

        // transform x/y coordinates to a vector to optimize
        var initial = new Array(2*sets.length);
        for (var i = 0; i < sets.length; ++i) {
            initial[2 * i] = sets[i].x;
            initial[2 * i + 1] = sets[i].y;
        }

        // optimize initial layout from our loss function
        var totalFunctionCalls = 0;
        var solution = venn.fmin(
            function(values) {
                totalFunctionCalls += 1;
                var current = new Array(sets.length);
                for (var i = 0; i < sets.length; ++i) {
                    current[i] = {x: values[2 * i],
                                  y: values[2 * i + 1],
                                  radius : sets[i].radius,
                                  size : sets[i].size};
                }
                return lossFunction(current, overlaps);
            },
            initial,
            parameters);

        // transform solution vector back to x/y points
        var positions = solution.solution;
        for (i = 0; i < sets.length; ++i) {
            sets[i].x = positions[2 * i];
            sets[i].y = positions[2 * i + 1];
        }

        return sets;
    };

    /** Returns the distance necessary for two circles of radius r1 + r2 to
    have the overlap area 'overlap' */
    venn.distanceFromIntersectArea = function(r1, r2, overlap) {
        // handle complete overlapped circles
        if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap) {
            return Math.abs(r1 - r2);
        }

        return venn.bisect(function(distance) {
            return circleIntersection.circleOverlap(r1, r2, distance) - overlap;
        }, 0, r1 + r2);
    };

    /// gets a matrix of euclidean distances between all sets in venn diagram
    venn.getDistanceMatrix = function(sets, overlaps) {
        // initialize an empty distance matrix between all the points
        var distances = [];
        for (var i = 0; i < sets.length; ++i) {
            distances.push([]);
            for (var j = 0; j < sets.length; ++j) {
                distances[i].push(0);
            }
        }

        // compute distances between all the points
        for (i = 0; i < overlaps.length; ++i) {
            var current = overlaps[i];
            if (current.sets.length !== 2) {
                continue;
            }

            var left = current.sets[0],
                right = current.sets[1],
                r1 = Math.sqrt(sets[left].size / Math.PI),
                r2 = Math.sqrt(sets[right].size / Math.PI),
                distance = venn.distanceFromIntersectArea(r1, r2, current.size);
            distances[left][right] = distances[right][left] = distance;
        }
        return distances;
    };

    /** Lays out a Venn diagram greedily, going from most overlapped sets to
    least overlapped, attempting to position each new set such that the
    overlapping areas to already positioned sets are basically right */
    venn.greedyLayout = function(sets, overlaps) {
        // give each set a default position + radius
        var setOverlaps = {};
        for (var i = 0; i < sets.length; ++i) {
            setOverlaps[i] = [];
            sets[i].radius = Math.sqrt(sets[i].size / Math.PI);
            sets[i].x = sets[i].y = 0;
        }

        // map each set to a list of all the other sets that overlap it
        for (i = 0; i < overlaps.length; ++i) {
            var current = overlaps[i];
            if (current.sets.length !== 2) {
                continue;
            }

            var left = current.sets[0], right = current.sets[1];
            setOverlaps[left].push ({set:right, size:current.size});
            setOverlaps[right].push({set:left,  size:current.size});
        }

        // get list of most overlapped sets
        var mostOverlapped = [];
        for (var set in setOverlaps) {
            if (setOverlaps.hasOwnProperty(set)) {
                var size = 0;
                for (i = 0; i < setOverlaps[set].length; ++i) {
                    size += setOverlaps[set][i].size;
                }

                mostOverlapped.push({set: set, size:size});
            }
        }

        // sort by size desc
        function sortOrder(a,b) {
            return b.size - a.size;
        }
        mostOverlapped.sort(sortOrder);

        // keep track of what sets have been laid out
        var positioned = {};
        function isPositioned(element) {
            return element.set in positioned;
        }

        // adds a point to the output
        function positionSet(point, index) {
            sets[index].x = point.x;
            sets[index].y = point.y;
            positioned[index] = true;
        }

        // add most overlapped set at (0,0)
        positionSet({x: 0, y: 0}, mostOverlapped[0].set);

        // get distances between all points
        var distances = venn.getDistanceMatrix(sets, overlaps);

        for (i = 1; i < mostOverlapped.length; ++i) {
            var setIndex = mostOverlapped[i].set,
                overlap = setOverlaps[setIndex].filter(isPositioned);
            set = sets[setIndex];
            overlap.sort(sortOrder);

            if (overlap.length === 0) {
                throw "Need overlap information for set " + JSON.stringify( set );
            }

            var points = [];
            for (var j = 0; j < overlap.length; ++j) {
                // get appropriate distance from most overlapped already added set
                var p1 = sets[overlap[j].set],
                    d1 = distances[setIndex][overlap[j].set];

                // sample positions at 90 degrees for maximum aesthetics
                points.push({x : p1.x + d1, y : p1.y});
                points.push({x : p1.x - d1, y : p1.y});
                points.push({y : p1.y + d1, x : p1.x});
                points.push({y : p1.y - d1, x : p1.x});

                // if we have at least 2 overlaps, then figure out where the
                // set should be positioned analytically and try those too
                for (var k = j + 1; k < overlap.length; ++k) {
                    var p2 = sets[overlap[k].set],
                        d2 = distances[setIndex][overlap[k].set];

                    var extraPoints = circleIntersection.circleCircleIntersection(
                        { x: p1.x, y: p1.y, radius: d1},
                        { x: p2.x, y: p2.y, radius: d2});

                    for (var l = 0; l < extraPoints.length; ++l) {
                        points.push(extraPoints[l]);
                    }
                }
            }

            // we have some candidate positions for the set, examine loss
            // at each position to figure out where to put it at
            var bestLoss = 1e50, bestPoint = points[0];
            for (j = 0; j < points.length; ++j) {
                sets[setIndex].x = points[j].x;
                sets[setIndex].y = points[j].y;
                var loss = venn.lossFunction(sets, overlaps);
                if (loss < bestLoss) {
                    bestLoss = loss;
                    bestPoint = points[j];
                }
            }

            positionSet(bestPoint, setIndex);
        }

        return sets;
    };

    /// Uses multidimensional scaling to approximate a first layout here
    venn.classicMDSLayout = function(sets, overlaps) {
        // get the distance matrix
        var distances = venn.getDistanceMatrix(sets, overlaps);

        // get positions for each set
        var positions = mds.classic(distances);

        // translate back to (x,y,radius) coordinates
        for (var i = 0; i < sets.length; ++i) {
            sets[i].x = positions[i][0];
            sets[i].y = positions[i][1];
            sets[i].radius = Math.sqrt(sets[i].size / Math.PI);
        }
        return sets;
    };

    /** Given a bunch of sets, and the desired overlaps between these sets - computes
    the distance from the actual overlaps to the desired overlaps. Note that
    this method ignores overlaps of more than 2 circles */
    venn.lossFunction = function(sets, overlaps) {
        var output = 0;

        function getCircles(indices) {
            return indices.map(function(i) { return sets[i]; });
        }

        for (var i = 0; i < overlaps.length; ++i) {
            var area = overlaps[i], overlap;
            if (area.sets.length == 2) {
                var left = sets[area.sets[0]],
                    right = sets[area.sets[1]];
                overlap = circleIntersection.circleOverlap(left.radius, right.radius,
                                circleIntersection.distance(left, right));
            } else {
                overlap = circleIntersection.intersectionArea(getCircles(area.sets));
            }

            output += (overlap - area.size) * (overlap - area.size);
        }

        return output;
    };

    /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in
    a rectangle of width/height - with padding around the borders. */
    venn.scaleSolution = function(solution, width, height, padding) {
        var minMax = function(d) {
            var hi = Math.max.apply(null, solution.map(
                                    function(c) { return c[d] + c.radius; } )),
                lo = Math.min.apply(null, solution.map(
                                    function(c) { return c[d] - c.radius;} ));
            return {max:hi, min:lo};
        };

        width -= 2*padding;
        height -= 2*padding;

        var xRange = minMax('x'),
            yRange = minMax('y'),
            xScaling = width  / (xRange.max - xRange.min),
            yScaling = height / (yRange.max - yRange.min),
            scaling =  Math.min(yScaling, xScaling);

        for (var i = 0; i < solution.length; ++i) {
            var set = solution[i];
            set.radius = scaling * set.radius;
            set.x = padding + (set.x - xRange.min) * scaling;
            set.y = padding + (set.y - yRange.min) * scaling;
        }
        solution.scaling = scaling;

        return solution;
    };

    function weightedSum(a, b) {
        var ret = new Array(a[1].length || 0);
        for (var j = 0; j < ret.length; ++j) {
            ret[j] = a[0] * a[1][j] + b[0] * b[1][j];
        }
        return ret;
    }

    function centerVennDiagram( diagram, width, height, padding ) {
        var diagramBoundaries;
        var allowedWidth = width - ( 2 * ( padding || 10 ) );
        var allowedHeight = height - ( 2 * ( padding || 10 ) );
        var scale;
        var transformX, transformY;
        var transform = "";

        if ( diagram ) {
            diagramBoundaries = diagram[ 0 ][ 0 ].getBBox();
            if ( diagramBoundaries && width && height ) {

                //  See if we need to scale to fit the width/height
                if ( diagramBoundaries.width > allowedWidth ) {
                    scale = allowedWidth / diagramBoundaries.width;
                }
                if ( diagramBoundaries.height > allowedHeight ) {
                    if ( !scale || ( allowedHeight / diagramBoundaries.height ) < scale ) {
                        scale = allowedHeight / diagramBoundaries.height;
                    }
                }

                if ( scale ) {
                    transform = "scale(" + scale + ")";
                }
                else {
                    scale = 1;
                }

          
              let vennWidth = (data.sets[1].x - data.sets[0].x) +  data.sets[0].radius + data.sets[1].radius
              transformX = hRect / 2 - vennWidth / 2;
              transformY = wRect / 2 - data.sets[1].y;
                diagram.attr( "transform", "translate(" + transformX + ","  + transformY + ") " + transform );
            }
        }
    }

    /** finds the zeros of a function, given two starting points (which must
     * have opposite signs */
    venn.bisect = function(f, a, b, parameters) {
        parameters = parameters || {};
        var maxIterations = parameters.maxIterations || 100,
            tolerance = parameters.tolerance || 1e-10,
            fA = f(a),
            fB = f(b),
            delta = b - a;

        if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
        }

        if (fA === 0) return a;
        if (fB === 0) return b;

        for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid = a + delta,
                fMid = f(mid);

            if (fMid * fA >= 0) {
                a = mid;
            }

            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {
                return mid;
            }
        }
        return a + delta;
    };

    /** minimizes a function using the downhill simplex method */
    venn.fmin = function(f, x0, parameters) {
        parameters = parameters || {};

        var maxIterations = parameters.maxIterations || x0.length * 200,
            nonZeroDelta = parameters.nonZeroDelta || 1.1,
            zeroDelta = parameters.zeroDelta || 0.001,
            minErrorDelta = parameters.minErrorDelta || 1e-5,
            rho = parameters.rho || 1,
            chi = parameters.chi || 2,
            psi = parameters.psi || -0.5,
            sigma = parameters.sigma || 0.5,
            callback = parameters.callback;

        // initialize simplex.
        var N = x0.length,
            simplex = new Array(N + 1);
        simplex[0] = x0;
        simplex[0].fx = f(x0);
        for (var i = 0; i < N; ++i) {
            var point = x0.slice();
            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;
            simplex[i+1] = point;
            simplex[i+1].fx = f(point);
        }

        var sortOrder = function(a, b) { return a.fx - b.fx; };

        for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);
            if (callback) {
                callback(simplex);
            }

            if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) {
                break;
            }

            // compute the centroid of all but the worst point in the simplex
            var centroid = new Array(N);
            for (i = 0; i < N; ++i) {
                centroid[i] = 0;
                for (var j = 0; j < N; ++j) {
                    centroid[i] += simplex[j][i];
                }
                centroid[i] /= N;
            }

            // reflect the worst point past the centroid  and compute loss at reflected
            // point
            var worst = simplex[N];
            var reflected = weightedSum([1+rho, centroid], [-rho, worst]);
            reflected.fx = f(reflected);

            var replacement = reflected;

            // if the reflected point is the best seen, then possibly expand
            if (reflected.fx <= simplex[0].fx) {
                var expanded = weightedSum([1+chi, centroid], [-chi, worst]);
                expanded.fx = f(expanded);
                if (expanded.fx < reflected.fx) {
                    replacement = expanded;
                }
            }

            // if the reflected point is worse than the second worst, we need to
            // contract
            else if (reflected.fx >= simplex[N-1].fx) {
                var shouldReduce = false;
                var contracted;

                if (reflected.fx <= worst.fx) {
                    // do an inside contraction
                    contracted = weightedSum([1+psi, centroid], [-psi, worst]);
                    contracted.fx = f(contracted);
                    if (contracted.fx < worst.fx) {
                        replacement = contracted;
                    } else {
                        shouldReduce = true;
                    }
                } else {
                    // do an outside contraction
                    contracted = weightedSum([1-psi * rho, centroid], [psi*rho, worst]);
                    contracted.fx = f(contracted);
                    if (contracted.fx <= reflected.fx) {
                        replacement = contracted;
                    } else {
                        shouldReduce = true;
                    }
                }

                if (shouldReduce) {
                    // do reduction. doesn't actually happen that often
                    for (i = 1; i < simplex.length; ++i) {
                        simplex[i] = weightedSum([1 - sigma, simplex[0]],
                                                 [sigma - 1, simplex[i]]);
                        simplex[i].fx = f(simplex[i]);
                    }
                }
            }

            simplex[N] = replacement;
        }

        simplex.sort(sortOrder);
        return {f : simplex[0].fx,
                solution : simplex[0]};
    };

    /** returns a svg path of the intersection area of a bunch of circles */
    venn.intersectionAreaPath = function(circles) {
        var stats = {};
        circleIntersection.intersectionArea(circles, stats);
        var arcs = stats.arcs;

        if (arcs.length == 0) {
            return "M 0 0";
        }

        var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
        for (var i = 0; i < arcs.length; ++i) {
            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
            ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
        }

        return ret.join(" ");
    }
  
     venn.intersectionAreaSplitPath = function(circles, isRightPath, isLeftPath) {
        var stats = {};
        circleIntersection.intersectionArea(circles, stats);
        var arcs = stats.arcs;

        if (arcs.length == 0) {
            return "M 0 0";
        }

        var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
        for (var i = 0; i < arcs.length; ++i) {
            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
            if( (i==1 && isRightPath) || (i==0 && isLeftPath)){
              ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
            }
            else{
              ret.push("\nA", 0, 0, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
            }
           
        }

        return ret.join(" ");
    }
    
    venn.drawD3Diagram = function(element, dataset, width, height, parameters) {
        parameters = parameters || {};

        var colours = d3.scale.category10(),
            circleFillColours = parameters.circleFillColours || colours,
            circleStrokeColours = parameters.circleStrokeColours || circleFillColours,
            circleStrokeWidth = parameters.circleStrokeWidth || function(i) { return 0; },
            textFillColours = parameters.textFillColours || colours,
            textStrokeColours = parameters.textStrokeColours || textFillColours,
            nodeOpacity = parameters.opacity || 0.3,
            padding = parameters.padding || 10;

        dataset = venn.scaleSolution(dataset, width, height, padding);
        var svg = element.append("svg").attr('id', 'svg-wrapper');
        var diagram = svg.append( "g" ).attr('id', 'union-all');
        var nodes = diagram.append("g").selectAll("g")
                         .data(dataset, function(d) {
                           return d.label;
                         });
        var nodeEnter = nodes.enter()
          .append("g").attr("style", "transition: opacity 2s")
          .attr('class', 'node');

        nodeEnter.append("circle").attr("id",  function(d) { return `circle-${d.label}` })
               .attr("r",  function(d) { return d.radius; })
               .style("fill-opacity", nodeOpacity)
               .attr("cx", function(d) { return d.x; })
               .attr("cy", function(d) { return d.y; })
               .style("stroke", function(d, i) { return circleStrokeColours(i); })
               .style("stroke-width", function(d, i) { return circleStrokeWidth(i); })
               .style("fill", function(d, i) { return circleFillColours(i); });

        nodeEnter.append("text")
               .attr("x", function(d, i) { return d.x + (d.radius + 20) * Math.sin(-Math.PI / 3 + i * 2 *  Math.PI / 3); })
               .attr("y", function(d, i) { return d.y - (d.radius + 20) * Math.cos(-Math.PI / 3 + i * 2 *  Math.PI / 3); })
               .attr("text-anchor", "middle")
               .attr("dy", "0.35em")
                .attr("font-size", fontSize)
               .style("stroke", function(d, i) { return textStrokeColours(i); })
               .style("fill", function(d, i) { return textFillColours(i); })
               .text(function(d) { return d.label; });

        var circles = nodes.selectAll("circle");

        var text = nodes.selectAll("text");
        centerVennDiagram( diagram, width, height, padding );
        return {'svg' : svg,
                'nodes' : nodes,
                'circles' : circles,
                'text' : text };
    };

    venn.updateD3Diagram = function(element, dataset, parameters) {
        parameters = parameters || {};

        var colours = d3.scale.category10(),
            circleFillColours = parameters.circleFillColours || colours,
            circleStrokeColours = parameters.circleStrokeColours || circleFillColours,
            circleStrokeWidth = parameters.circleStrokeWidth || function(i) { return 0; },
            textFillColours = parameters.textFillColours || colours,
            textStrokeColours = parameters.textStrokeColours || textFillColours,
            nodeOpacity = parameters.opacity || 0.3,
            padding = parameters.padding || 0;

        var svg = element.select("svg"),
            width = parseInt(svg.attr('width'), 10),
            height = parseInt(svg.attr('height'), 10),
            circles, texts;

        dataset = venn.scaleSolution(dataset, width, height, 0);
        var nodes = svg.select('g').select('g').selectAll("g.node")
            .data(dataset, function(d) { return d.label; });

        nodes.exit().remove();

        var nodeEnter = nodes.enter()
          .append("g")
          .attr('class', 'node');

        nodeEnter.append("circle")
               .style("fill-opacity", nodeOpacity)
               .style("stroke", function(d, i) { return circleStrokeColours(i); })
               .style("stroke-width", function(d, i) { return circleStrokeWidth(i); })
               .style("fill", function(d, i) { return circleFillColours(i); });

        nodeEnter.append("text")
               .attr("text-anchor", "middle")
               .attr("dy", "0.35em")
                .attr("font-size", fontSize)
               .style("stroke", function(d, i) { return textStrokeColours(i); })
               .style("fill", function(d, i) { return textFillColours(i); })

        nodes.select("circle")
            .transition()
            .duration(400)
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("r",  function(d) { return d.radius; });

        nodes.select("text")
            .transition()
            .duration(400)
            .text(function(d) { return d.label; })
              .attr("font-size", fontSize)
            .attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y; });
    };
  
  return venn;

}
```



```{ojs}
//| echo: false
circleIntersection = {
  let circleIntersection = {}
  var SMALL = 1e-10;

    /** Returns the intersection area of a bunch of circles (where each circle
     is an object having an x,y and radius property) */
    circleIntersection.intersectionArea = function(circles, stats) {
        // get all the intersection points of the circles
        var intersectionPoints = getIntersectionPoints(circles);

        // filter out points that aren't included in all the circles
        var innerPoints = intersectionPoints.filter(function (p) {
            return circleIntersection.containedInCircles(p, circles);
        });

        var arcArea = 0, polygonArea = 0, arcs = [], i;

        // if we have intersection points that are within all the circles,
        // then figure out the area contained by them
        if (innerPoints.length > 1) {
            // sort the points by angle from the center of the polygon, which lets
            // us just iterate over points to get the edges
            var center = circleIntersection.getCenter(innerPoints);
            for (i = 0; i < innerPoints.length; ++i ) {
                var p = innerPoints[i];
                p.angle = Math.atan2(p.x - center.x, p.y - center.y);
            }
            innerPoints.sort(function(a,b) { return b.angle - a.angle;});

            // iterate over all points, get arc between the points
            // and update the areas
            var p2 = innerPoints[innerPoints.length - 1];
            for (i = 0; i < innerPoints.length; ++i) {
                var p1 = innerPoints[i];

                // polygon area updates easily ...
                polygonArea += (p2.x + p1.x) * (p1.y - p2.y);

                // updating the arc area is a little more involved
                var midPoint = {x : (p1.x + p2.x) / 2,
                                y : (p1.y + p2.y) / 2},
                    arc = null;

                for (var j = 0; j < p1.parentIndex.length; ++j) {
                    if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
                        // figure out the angle halfway between the two points
                        // on the current circle
                        var circle = circles[p1.parentIndex[j]],
                            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
                            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);

                        var angleDiff = (a2 - a1);
                        if (angleDiff < 0) {
                            angleDiff += 2*Math.PI;
                        }

                        // and use that angle to figure out the width of the
                        // arc
                        var a = a2 - angleDiff/2,
                            width = circleIntersection.distance(midPoint, {
                                x : circle.x + circle.radius * Math.sin(a),
                                y : circle.y + circle.radius * Math.cos(a)
                            });

                        // pick the circle whose arc has the smallest width
                        if ((arc === null) || (arc.width > width)) {
                            arc = { circle : circle,
                                    width : width,
                                    p1 : p1,
                                    p2 : p2};
                        }
                    }
                }
                arcs.push(arc);
                arcArea += circleIntersection.circleArea(arc.circle.radius, arc.width);
                p2 = p1;
            }
        } else {
            // no intersection points, is either disjoint - or is completely
            // overlapped. figure out which by examining the smallest circle
            var smallest = circles[0];
            for (i = 1; i < circles.length; ++i) {
                if (circles[i].radius < smallest.radius) {
                    smallest = circles[i];
                }
            }

            // make sure the smallest circle is completely contained in all
            // the other circles
            var disjoint = false;
            for (i = 0; i < circles.length; ++i) {
                if (circleIntersection.distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
                    disjoint = true;
                    break;
                }
            }

            if (disjoint) {
                arcArea = polygonArea = 0;

            } else {
                arcArea = smallest.radius * smallest.radius * Math.PI;
                arcs.push({circle : smallest,
                           p1: { x: smallest.x,        y : smallest.y + smallest.radius},
                           p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},
                           width : smallest.radius * 2 });
            }
        }

        polygonArea /= 2;
        if (stats) {
            stats.area = arcArea + polygonArea;
            stats.arcArea = arcArea;
            stats.polygonArea = polygonArea;
            stats.arcs = arcs;
            stats.innerPoints = innerPoints;
            stats.intersectionPoints = intersectionPoints;
        }

        return arcArea + polygonArea;
    };

    /** returns whether a point is contained by all of a list of circles */
    circleIntersection.containedInCircles = function(point, circles) {
        for (var i = 0; i < circles.length; ++i) {
            if (circleIntersection.distance(point, circles[i]) > circles[i].radius + SMALL) {
                return false;
            }
        }
        return true;
    };

    /** Gets all intersection points between a bunch of circles */
    function getIntersectionPoints(circles) {
        var ret = [];
        for (var i = 0; i < circles.length; ++i) {
            for (var j = i + 1; j < circles.length; ++j) {
                var intersect = circleIntersection.circleCircleIntersection(circles[i],
                                                              circles[j]);
                for (var k = 0; k < intersect.length; ++k) {
                    var p = intersect[k];
                    p.parentIndex = [i,j];
                    ret.push(p);
                }
            }
        }
        return ret;
    }

    circleIntersection.circleIntegral = function(r, x) {
        var y = Math.sqrt(r * r - x * x);
        return x * y + r * r * Math.atan2(x, y);
    };

    /** Returns the area of a circle of radius r - up to width */
    circleIntersection.circleArea = function(r, width) {
        return circleIntersection.circleIntegral(r, width - r) - circleIntersection.circleIntegral(r, -r);
    };


    /** euclidean distance between two points */
    circleIntersection.distance = function(p1, p2) {
        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +
                         (p1.y - p2.y) * (p1.y - p2.y));
    };


    /** Returns the overlap area of two circles of radius r1 and r2 - that
    have their centers separated by distance d. Simpler faster
    circle intersection for only two circles */
    circleIntersection.circleOverlap = function(r1, r2, d) {
        // no overlap
        if (d >= r1 + r2) {
            return 0;
        }

        // completely overlapped
        if (d <= Math.abs(r1 - r2)) {
            return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
        }

        var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),
            w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
        return circleIntersection.circleArea(r1, w1) + circleIntersection.circleArea(r2, w2);
    };


    /** Given two circles (containing a x/y/radius attributes),
    returns the intersecting points if possible.
    note: doesn't handle cases where there are infinitely many
    intersection points (circles are equivalent):, or only one intersection point*/
    circleIntersection.circleCircleIntersection = function(p1, p2) {
        var d = circleIntersection.distance(p1, p2),
            r1 = p1.radius,
            r2 = p2.radius;

        // if to far away, or self contained - can't be done
        if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {
            return [];
        }

        var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
            h = Math.sqrt(r1 * r1 - a * a),
            x0 = p1.x + a * (p2.x - p1.x) / d,
            y0 = p1.y + a * (p2.y - p1.y) / d,
            rx = -(p2.y - p1.y) * (h / d),
            ry = -(p2.x - p1.x) * (h / d);

        return [{ x: x0 + rx, y : y0 - ry },
                { x: x0 - rx, y : y0 + ry }];
    };

    /** Returns the center of a bunch of points */
    circleIntersection.getCenter = function(points) {
        var center = { x: 0, y: 0};
        for (var i =0; i < points.length; ++i ) {
            center.x += points[i].x;
            center.y += points[i].y;
        }
        center.x /= points.length;
        center.y /= points.length;
        return center;
    };
return circleIntersection;
}


```




```{ojs}
//| echo: false
mds = {
  let mds = {}
  mds.classic = function(distances, dimensions) {
    dimensions = dimensions || 2;

    // square distances
    var M = numeric.mul(-.5, numeric.pow(distances, 2));

    // double centre the rows/columns
    function mean(A) { return numeric.div(numeric.add.apply(null, A), A.length); }
    var rowMeans = mean(M),
        colMeans = mean(numeric.transpose(M)),
        totalMean = mean(rowMeans);

    for (var i = 0; i < M.length; ++i) {
        for (var j =0; j < M[0].length; ++j) {
            M[i][j] += totalMean - rowMeans[i] - colMeans[j];
        }
    }

    // take the SVD of the double centred matrix, and return the
    // points from it
    var ret = numeric.svd(M),
        eigenValues = numeric.sqrt(ret.S);
    return ret.U.map(function(row) {
        return numeric.mul(row, eigenValues).splice(0, dimensions);
    });
};
  return mds;
}
```

```{ojs}
//| echo: false
d3 = require('d3@v3')
```





1. FRAGE: Wo finde ich eine Probeklausur? -- ANTWORT: [Dieser Tag](https://datenwerk.netlify.app/#category=qm2-pruefung)  stellt Fragen einer Probeprüfung zusammen.

2. FRAGE: Wie bereite ich mich gut auf die Prüfung vor? -- ANTWORT:
[Hier](https://hinweisbuch.netlify.app/hinweise-pruefungsvorbereitung-frame) finden Sie Tipps zur Prüfungsvorbereitung.

3. FRAGE: Wenn man '(Intercept)' benutzt, welche Anführungszeichen sind die richtigen? Bei verschiedenen Anführungszeichen, also ' oder \` oder ´ kommen entweder keine oder sogar verschiedene Ergebnisse raus. -- ANTWORT: Normalerweise ist innerhalb von R-Befehlen aus dem Tidyverse keine Anführungsstriche für Spaltennamen nötig. Wenn es allerdings ein "verbotener" Name ist, muss man aufpassen. `(Intercept)` ist so ein verbotener Variablenname. Warum verboten? Ein "braver" Variablenname (in R) muss mit einem Buchstaben beginnen und darf keine Sonderzeichen (`(, {, #,` etc.) enthalten. Hat man aber einen an sich unerlaubten Variablennamen, so kann man den trotzdem verwenden, *wenn* man ihn mit Backticks (\`) umgibt, also wie in `\(Intercept)\`). Doppelte und einfache Anführungsstriche sind in R übrigens beide okay, wenn man etwa einen String (Text) auszeichnen will, aber im Rahmen von Tidyverse nicht nötig für Variablennamen.

4. FRAGE: Woher weiß ich, dass ich die Prädiktoren vorher zentrieren muss? Kann man das aus der Aufgabenstellung irgendwie herauslesen? Z.B. wie bei Tutorium Aufgabe 10.1 d). -- ANTWORT: Es gibt mehrere Gründe, Variablen zu zentrieren, dazu zählen 1) bessere Interpretation des Intercepts, 2) bessere Interpretation von Interaktionseffekten, 3) Verringerung von Kollinearität. Die Steigung (beta 1) verändert sich (fast immer) aber nicht durch das Zentrieren, ebenso wie R-Quadrat.


5. FRAGE: Bei der Bearbeitung der Prüfung heute ist ein Fehler aufgekommen, den ich bis jetzt nicht verstehe. Deshalb war es auch für mich nicht möglich die Aufgabe zu bearbeiten. Die AV high Aufteilung in die Werte 0 und 1 (0 = AV <= median (AV)) (1 =AV > median(AV) hat geklappt.
Die UV high Aufteilung in die Werte 0 und 1 (0 = UV <= median (UV)) (1 =UV > median(UV) hat dabei aber nicht geklappt.
Anstatt die Werte 0 und 1 bei der neuen UV_high Spalte zu bekommen, kommen nur Nas raus. Auch mit dem Befehl drop_na hat es nicht geklappt. Dies habe ich nicht nur mit dem RStudio auf meinem Computer versucht sondern auch über die Cloud über mein IPad. (Bei beiden Geräten kam es zuvor noch nie zu Problemen) Hier mein R-Code:


```{r}
#| message: false
library(tidyverse)
#library(easystats)
#library(rstanarm)

data("msleep", package = "ggplot2")

msleep1 <-
  msleep |> 
    mutate(av_high = case_when(awake > median(awake) ~ 1,
                               awake <= median(awake) ~ 0))

msleep2 <-
  msleep1 |> 
    mutate(uv_high = case_when(sleep_rem > median(sleep_rem) ~ 1,
                               sleep_rem <= median(sleep_rem) ~ 0))
  
msleep2 |> 
count(uv_high)
```

ANTWORT: Sie haben nicht die fehlenden Werte ausgeschlossen. Wenn Sie die fehlenden Wert ausschließen, dann klappt es:


```{r}
msleep2 <-
  msleep1 |> 
  drop_na(sleep_rem) |>  # fehlende Werte aus `sleep_rem` entfernen
    mutate(uv_high = case_when(sleep_rem > median(sleep_rem) ~ 1,
                               sleep_rem <= median(sleep_rem) ~ 0))
  
msleep2 |> 
count(uv_high)
```


6. FRAGE: Ich habe meine Lösungswege mit Ihren abgeglichen und finde keinen bedeutenden Unterschied. Dennoch erhalte ich andere Ergebnisse, welche nicht im Toleranzbereich liegen. Um das nochmals zu überprüfen, habe ich Ihre Lösungswege 1:1 in mein RStudio übertragen, aber auch dann erhalte ich nicht die angegebene Lösung. -- ANTWORT: Es sollte ein Modell berechnet werden mit z-transformierten Variablen. Für die UV war der ROPE anzugeben. Leider haben Sie vergessen, die Daten zu z-transformieren.

Hier ist das Modell *ohne* z-Transformation:

```{r}
library(rstanarm)
library(easystats)
library(dplyr)

penguins <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/palmerpenguins/penguins.csv")

m1 <- stan_glm(bill_length_mm ~ year, data = penguins)

rope(m1)
```

Hier ist das Modell *mit* z-Transformation:

```{r}
p2 <- 
  penguins |> 
  select(bill_length_mm, year) |> 
  standardise()

m2 <- stan_glm(bill_length_mm ~ year, data = p2)

rope(m2)
```


Der Wert von `m2` findet sich in der Musterlösung. Man beachte, dass sich die Rope-Werte von `m1` und `m2` deutlich unterscheiden.

